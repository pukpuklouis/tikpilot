# Task ID: 3
# Title: Containerize Application with Docker
# Status: pending
# Dependencies: 1, 2
# Priority: high
# Description: Create Docker configuration for backend, frontend, and development environment.
# Details:
1. Create a multi-stage Dockerfile for the Rust backend
2. Create a Dockerfile for the Remix frontend
3. Set up Docker Compose configuration for local development
4. Configure volume mounting for development code
5. Set up environment variables for services
6. Configure networking between containers
7. Add health checks for services
8. Optimize container sizes using multi-stage builds

# Test Strategy:
Verify containers start successfully with docker-compose up. Test communication between services. Ensure volumes are properly mounted for development. Verify hot-reloading works in development mode.

# Subtasks:
## 1. Create Docker configuration for the Rust backend [pending]
### Dependencies: None
### Description: Implement a multi-stage Dockerfile for the Rust backend that optimizes container size while ensuring proper build and runtime environments.
### Details:
Implementation steps:
1. Create a Dockerfile in the backend directory
2. Set up a multi-stage build with:
   - First stage: Use rust:slim as build image
   - Install build dependencies and compile the application
   - Second stage: Use debian:slim-bookworm as runtime image
   - Copy only the compiled binary and necessary runtime files
3. Configure proper WORKDIR, USER (non-root), and ENTRYPOINT
4. Add health check using HEALTHCHECK instruction that tests the application's /health endpoint
5. Optimize the image by:
   - Using .dockerignore to exclude unnecessary files
   - Minimizing layers with combined RUN commands
   - Setting appropriate environment variables

Testing approach:
1. Build the Docker image: `docker build -t backend:latest ./backend`
2. Run the container: `docker run -p 8080:8080 backend:latest`
3. Verify the application starts correctly
4. Test the health check: `docker inspect --format='{{.State.Health.Status}}' <container_id>`
5. Check image size: `docker images backend:latest`

## 2. Create Docker configuration for the Remix frontend [pending]
### Dependencies: None
### Description: Implement a Dockerfile for the Remix frontend that handles both build and runtime environments efficiently.
### Details:
Implementation steps:
1. Create a Dockerfile in the frontend directory
2. Set up a multi-stage build with:
   - First stage: Use node:18-alpine as build image
   - Install dependencies with npm/yarn and build the Remix application
   - Second stage: Use node:18-alpine as runtime image
   - Copy built assets and necessary runtime files
3. Configure proper WORKDIR, USER (non-root), and CMD
4. Add health check using HEALTHCHECK instruction that tests the application's base URL
5. Optimize the image by:
   - Using .dockerignore to exclude node_modules, .git, etc.
   - Caching node_modules for faster builds
   - Setting NODE_ENV=production for runtime

Testing approach:
1. Build the Docker image: `docker build -t frontend:latest ./frontend`
2. Run the container: `docker run -p 3000:3000 frontend:latest`
3. Verify the application starts and is accessible at http://localhost:3000
4. Test the health check: `docker inspect --format='{{.State.Health.Status}}' <container_id>`
5. Check image size: `docker images frontend:latest`

## 3. Set up Docker Compose for local development environment [pending]
### Dependencies: 3.1, 3.2
### Description: Create a Docker Compose configuration that orchestrates the backend and frontend containers with proper networking, volume mounting, and environment variables for development.
### Details:
Implementation steps:
1. Create a docker-compose.yml file in the project root
2. Define services for:
   - Backend service using the Dockerfile from subtask 1
   - Frontend service using the Dockerfile from subtask 2
   - Any additional services needed (database, cache, etc.)
3. Configure networking:
   - Create a custom network for inter-service communication
   - Map appropriate ports to host machine
   - Set service names for DNS resolution
4. Set up volume mounts for development:
   - Mount backend source code directory to enable hot-reloading
   - Mount frontend source code directory for live development
   - Use named volumes for persistent data (if applicable)
5. Configure environment variables:
   - Create a .env file for shared variables
   - Set service-specific environment variables in the compose file
   - Include development-specific settings
6. Add depends_on directives to establish proper startup order
7. Include healthcheck configurations to ensure services are ready

Testing approach:
1. Start the environment: `docker-compose up -d`
2. Verify all services start correctly: `docker-compose ps`
3. Test backend API access from frontend container
4. Make a code change in both frontend and backend to verify hot-reloading
5. Test environment variables are correctly passed to containers
6. Validate network connectivity between services
7. Shut down and restart to verify persistence: `docker-compose down && docker-compose up -d`

